% Team Note Sample Template
% These codes should be guaranteed, fast enough, short and easy to type.

\documentclass[landscape, 10pt, a4paper, oneside, twocolumn]{extarticle}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{import}

\usepackage{teamnote}

\teamnote{PetrSU}{QA}{(Remeslennikov, Evstafeev, Titov)}

\ShowUsage
\ShowComplexity
\HideAuthor

\begin{document}

\maketitlepage

% Make Pagebreak if you want.
% \pagebreak 



\section{Graphs}

\Algorithm
{Dinic}
{Almost linear in practice. $\mathcal{O}(m \sqrt n)$ on unit network.}
{$\mathcal{O}(n^{2}m)$}
{cpp}{source/graphs/dinic.cpp}

\Algorithm
{Mincost}
{Complexity is strange but in practice works nice.}
{$\mathcal{O}(something\ big,\ never\ reached\ in\ ACM\ tasks)$}
{cpp}{source/graphs/mincost.cpp}

\Algorithm
{Bridges and Cut points}
{Works with multi edges but adds extra $ \log n$.}
{$\mathcal{O}(n \log n)$}
{cpp}{source/graphs/bridges_and_cutpoints.cpp}

\Algorithm
{LCA with binary lifting}
{Need to rind dfs and precalc binary liftings.}
{$\mathcal{O}(\log n)$}
{cpp}{source/graphs/lca_binary_lifting_wiki_conspects.cpp}

\Algorithm
{Kuhn with greedy heuristic}
{Supposed to run faster than usual Kuhn.}
{$\mathcal{O}(n^{3})$}
{cpp}{source/graphs/kuhn_with_greedy_heuristic.cpp}

% TODO: weighted biparate matching
% \Algorithm
% {General Matching}
% {Use \texttt{init} to init, \texttt{addEdge} to add edges, \texttt{match} to get matching, \texttt{Match} to find maximum matching. Vertices have 1-based index.}
% {$\mathcal{O}(VE)$}
% {cpp}{source/GeneralMatching.cpp}




\section{Data Structures}

\Algorithm
{Treap}
{Implementation supports 2 kinds of operations: sum and reverse queries on $[l, r]$.}
{Building $\mathcal{O}(n \log n)$, Query $\mathcal{O}(\log n)$}
{cpp}{source/data_structures/treap.cpp}

\Algorithm
{Fenwick}
{Considered to work in constant time in practice.}
{$\mathcal{O}(\log n), \mathcal{O}(\log n)$}
{cpp}{source/data_structures/fenwick.cpp}

\Algorithm
{Sparse table}
{Not to fuck up.}
{$\mathcal{O}(n \log n), \mathcal{O}(1)$}
{cpp}{source/data_structures/sparse_table.cpp}




\section{Strings}

\Algorithm
{Polynomial hashes}
{Almost unbreakable.}
{$\mathcal{O}(n), \mathcal{O}(1)$}
{cpp}{source/strings/hashes.cpp}

% TODO: Manaker
% \Algorithm
% {Aho-Pidarasik}
% {Almost unbreakable.}
% {$\mathcal{O}(n), \mathcal{O}(1)$}
% {cpp}{source/strings/hashes.cpp}

% TODO: Add aho-corasick
% \Algorithm
% {Aho-Pidarasik}
% {Almost unbreakable.}
% {$\mathcal{O}(n), \mathcal{O}(1)$}
% {cpp}{source/strings/hashes.cpp}


\section{Math}

\Algorithm
{Linear inverse modulo prime}
{Suprisingly laconic.}
{$\mathcal{O}(p)$}
{cpp}{source/math/linear_inverse.cpp}

\Algorithm
{FFT}
{You never know, you never know...}
{$\mathcal{O}(n \log n)$}
{cpp}{source/math/fft.cpp}

\Algorithm
{Gauss}
{Solves system of linear equations.}
{$\mathcal{O}(n^{3})$}
{cpp}{source/math/gauss.cpp}



% TODO: Serega, add your own shit here
% \section{Geometry}

% \Algorithm
% {Smallest Enclosing Circle}
% {Use \texttt{solve} with \texttt{vector<Point>}. It returns \texttt{Circle c}, \texttt{c.p} is center, \texttt{c.r} is radius.}
% {$\mathcal{O}(n)$}
% {cpp}{source/SmallestEnclosingCircle.cpp}


\end{document}

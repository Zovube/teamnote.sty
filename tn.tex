% Team Note Sample Template
% These codes should be guaranteed, fast enough, short and easy to type.

\documentclass[landscape, 10pt, a4paper, oneside, twocolumn]{extarticle}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{import}
\usepackage{mathtools}

\usepackage{teamnote}

\teamnote{Petrozavodsk State University}{QA}{(Remeslennikov, Evstafeev, Titov)}

\ShowUsage
\ShowComplexity
\HideAuthor

\begin{document}

\maketitlepage

% TODO: Add pagebreak
% Make Pagebreak if you want.
% \pagebreak 





\section{Templates}

\Algorithm
{C++ template}
{Ez win template: go to St. Petersburg, write template, solve problems, submit solutions, get OK, win NEERC 2018}
{$\mathcal{O}(1)$}
{cpp}{source/templates/solution.cpp}

\Algorithm
{Stress test}
{When you feel bad, you run this code and go walk with green badge, and get OK}
{$\mathcal{O}(\infty)$}
{cpp}{source/templates/stress.cpp}

\section{Graphs}

\Algorithm
{Dinic}
{Almost linear in practice. $\mathcal{O}(m \sqrt n)$ on unit network.}
{$\mathcal{O}(n^{2}m)$}
{cpp}{source/graphs/dinic.cpp}

\Algorithm
{Mincost}
{Complexity is strange but in practice works nice.}
{$\mathcal{O}(N * M) * T(N, M)$, where $T(N, M)$ – time complexity for SPFA(or any other shortest path algorithm) for graph with $N$ vertex and $E$ edges.}
{cpp}{source/graphs/mincost.cpp}

\Algorithm
{Bridges and Cut points}
{Works with multi edges but adds extra $ \log n$.}
{$\mathcal{O}(n \log n)$}
{cpp}{source/graphs/bridges_and_cutpoints.cpp}

\Algorithm
{LCA with binary lifting}
{Need to rind dfs and precalc binary liftings.}
{Precalc – $\mathcal{O}(n \log n)$, Query – $\mathcal{O}(\log n)$}
{cpp}{source/graphs/lca_binary_lifting_wiki_conspects.cpp}

\Algorithm
{Kuhn with greedy heuristic}
{Supposed to run faster than usual Kuhn.}
{$\mathcal{O}(n^{3})$}
{cpp}{source/graphs/kuhn_with_greedy_heuristic.cpp}

\Algorithm
{Weighted biparate matching}
{Kuznecov favorite algorith}
{$\mathcal{O}(n^{3})$}
{cpp}{source/graphs/weighted_biparate_matching.cpp}


% TODO: weighted biparate matching
% \Algorithm
% {General Matching}
% {Use \texttt{init} to init, \texttt{addEdge} to add edges, \texttt{match} to get matching, \texttt{Match} to find maximum matching. Vertices have 1-based index.}
% {$\mathcal{O}(VE)$}
% {cpp}{source/GeneralMatching.cpp}




\section{Data Structures}

\Algorithm
{Treap}
{Implementation supports 2 kinds of operations: sum and reverse queries on $[l, r]$.}
{Building – $\mathcal{O}(n \log n)$, Query – $\mathcal{O}(\log n)$}
{cpp}{source/data_structures/treap.cpp}

\Algorithm
{Fenwick}
{Considered to work in constant time in practice.}
{$\mathcal{O}(\log n), \mathcal{O}(\log n)$}
{cpp}{source/data_structures/fenwick.cpp}

\Algorithm
{Sparse table}
{Not to fack up.}
{$\mathcal{O}(n \log n), \mathcal{O}(1)$}
{cpp}{source/data_structures/sparse_table.cpp}

\Algorithm
{Centroid Decomposition}
{Store something in centroids for example pair with distance to other vertices & etc.
Properties:
    \begin{enumerate}
        \item Depth of the CD tree $ \leq \mathcal{O}(\log n)$.
        \item Every vertex $v$ of the tree $t$ is centroid of some subtree of $t$.
        \item Every vertex belongs to $\mathcal{O}(\log n)$ subtrees of $T$.
        \item For any $u, v \in T (u \neq v)$ one of the following conditions is met:
            \begin{itemize}
                \item $T(v) \subset T(u)$
                \item $T(u) \subset T(v)$
                \item $T(u) \cap T(v) = \emptyset $
            \end{itemize}
        \item Simple path between every pair vertex $u, v$ has centroid $c \in T(t)$ such that $u, v \in T(c)$. 
    \end{enumerate}
}
{$\mathcal{O}(n \log n), \mathcal{O}(1)$}
{cpp}{source/data_structures/sparse_table.cpp}


\section{Strings}

\Algorithm
{Prefix-function}
{}
{$\mathcal{O}(n)$}
{cpp}{source/strings/prefix_function.cpp}

\Algorithm
{Z-function}
{}
{$\mathcal{O}(n)$}
{cpp}{source/strings/z_function.cpp}

\Algorithm
{Polynomial hashes}
{Almost unbreakable.}
{$\mathcal{O}(n), \mathcal{O}(1)$}
{cpp}{source/strings/hashes.cpp}

\Algorithm
{Manacher}
{$p[0][i]$ – even case, let $len = p[0][i]$,
it means that maximal even palindrome located on $[i - len, i + len - 1]$,

$p[1][i]$ – even case, let $len = p[0][i]$,
it means that maximal odd palindrome located on $[i - len, i + len]$
}
{$\mathcal{O}(n)$}
{cpp}{source/strings/manacher.cpp}

\Algorithm
{Suffix array}
{Implementation by Mihail Pyaderkin :)}
{$\mathcal{O}(n \log n)$}
{cpp}{source/strings/suffix_array.cpp}

\Algorithm
{LCP (Kasai)}
{Write suffix array and after that use this code}
{$\mathcal{O}(n)$}
{cpp}{source/strings/lcp_kasai.cpp}

\Algorithm
{Aho-Corasick}
{Build automaton on given dictionary}
{Building - $\mathcal{O}(\sum|words|)$}
{cpp}{source/strings/aho-corasick.cpp}


\Algorithm
{Palindromic tree}
{Implementation by Merkurev}
{Building - $\mathcal{O}(|s| \log \sum)$}
{cpp}{source/strings/palindromic_tree.cpp}





\section{Math}

\Algorithm
{Linear inverse modulo prime}
{Suprisingly laconic.}
{$\mathcal{O}(p)$}
{cpp}{source/math/linear_inverse.cpp}

\Algorithm
{FFT}
{You never know, you never know...}
{$\mathcal{O}(n \log n)$}
{cpp}{source/math/fft.cpp}

\Algorithm
{Gauss}
{Solves system of linear equations.}
{$\mathcal{O}(n^{3})$}
{cpp}{source/math/gauss.cpp}

\Algorithm
{Next combination}
{Gen C(N, K)}
{$\mathcal{O}(C_{n}^{k})$}
{cpp}{source/data_structures/next_combination.cpp}

\Algorithm
{Chineeze theorem find X}
{Find x from reminders.}
{$\mathcal{O}(K^{2})$}
{cpp}{source/math/chineeze_find_ans.cpp}

\Algorithm
{Calculating N! by prime P}
{Find N!}
{$\mathcal{O}(P log N)$}
{cpp}{source/math/n_fact_by_prime.cpp}

\Algorithm
{Gray's code}
{Numeric system with different between two adjansted numbers in 1 bit, ex: $000, 001, 011, 010, 110, 111, 101, 100$}
{$\mathcal{O}(1)$}
{cpp}{source/math/gray_code.cpp}

\Algorithm
{Euler function}
{$\phi(n) = $ count of number in $1..n$, with $gcd(i, n) = 1$}
{$\mathcal{O}(\sqrt{N})$}
{cpp}{source/math/euler_f.cpp}

\Algorithm
{Eratosthene's sieve}
{you can calculate with blocks, remember}
{$\mathcal{O}(N)$}
{cpp}{source/math/eratosthenes_sieve.cpp}

\Algorithm
{Extended gcd}
{Find $a x + b y = gcd(a, b)$}
{$\mathcal{O}(Good\ log\ max(A, B))$}
{cpp}{source/math/ext_gcd.cpp}

% TODO: Serega, add your own shit here
\section{Geometry}

\Formula
{Pick's Theorem}
{$S = I + \frac{B}{2} - 1$, where $I$ - count of points strictly inside polygon, $B$ - count of points on boundary.}

\Formula
{Two circles intersection}
{$A = -2 x_{2}, B = - 2 y_{2}, C = x_{2}^{2} + y_{2}^{2} + r_{1}^{2} - r_{2}^{2}$}

\Formula
{Distance on sphere}
{$L = R \times cos^{-1}( sin(\phi_{a}) sin(-+ \phi_{b}) + cos(\phi_{a}) cos(-+ \phi_{b}) cos(\lambda_{a} -+ \lambda_{b}) ) $}

\Formula
{Rotation matrix 2d}
{$M = \left( \begin{smallmatrix} cos\theta & - sin\theta \\ sin\theta & cos\theta \end{smallmatrix} \right)$}

\Formula
{Sphere coordinates}
{
    $r = \sqrt{x^{2} + y^{2} + z^{2}}, \theta = arccos(\frac{z}{r}), \phi = \arctan(\frac{y}{x})$ \\
    $x = r sin \theta cos \phi, y = r sin \theta \sin \phi, z = r cos \theta$ \\ 
}    

\Formula
{Rotation matrix by axis}
{ $ M = 
	\left ( 
		\begin{smallmatrix} 
			cos\theta + u_{x}^{2} (1 - cos\theta) \  & u_{x} u_{y} (1 - cos\theta) - u_{z} sin\theta \ & u_{x} u_{z} (1 - cos\theta) + u_{y} sin\theta \\ 
			u_{y} u_{x} (1 - cos\theta) + u_{z} sin\theta \ & cos\theta + u_{y}^{2} (1 - cos\theta) \ & u_{y} u_{z} (1 - cos\theta) - u_{x} sin\theta \\ 
			u_{z} u_{x} (1 - cos\theta) - u_{y} sin\theta \ & u_{z} u_{y} (1 - cos\theta) + u_{x} sin\theta \ & cos\theta + u_{z}^{2} (1 - cos\theta)
		\end{smallmatrix} 
	\right ) $
}

\Algorithm
{Minkovsky sum}
{Sort $V$ and $W$ by counterclockwise angle, leftmost bottommost first}
{$\mathcal{O}(n + m)$}
{cpp}{source/geometry/minkovsky.cpp}

\Algorithm
{Half plane intersection}
{Timon and Dimon never let it go}
{$\mathcal{O}(n logn)$}
{cpp}{source/geometry/half_plane_intersection.cpp}

\Algorithm
{Closest pair}
{Can be modificated to find triangle with minimal perimiter}
{$\mathcal{O}(n logn)$}
{cpp}{source/geometry/closest_pair.cpp}

% \Algorithm
% {Smallest Enclosing Circle}
% {Use \texttt{solve} with \texttt{vector<Point>}. It returns \texttt{Circle c}, \texttt{c.p} is center, \texttt{c.r} is radius.}
% {$\mathcal{O}(n)$}
% {cpp}{source/SmallestEnclosingCircle.cpp}

\end{document}
